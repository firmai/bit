<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Interpretable Machine Learning</title>
  <meta name="description" content="Machine learning algorithms usually operate as black boxes and it is unclear how they derived a certain decision. This book is a guide for practitioners on how to make machine learning decisions more interpretable.">
  <meta name="generator" content="bookdown 0.7 and GitBook 2.6.7">

  <meta property="og:title" content="Interpretable Machine Learning" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="Machine learning algorithms usually operate as black boxes and it is unclear how they derived a certain decision. This book is a guide for practitioners on how to make machine learning decisions more interpretable." />
  <meta name="github-repo" content="christophM/interpretable-ml-book" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Interpretable Machine Learning" />
  
  <meta name="twitter:description" content="Machine learning algorithms usually operate as black boxes and it is unclear how they derived a certain decision. This book is a guide for practitioners on how to make machine learning decisions more interpretable." />
  

<meta name="author" content="Christoph Molnar">


<meta name="date" content="2018-10-14">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="tree.html">
<link rel="next" href="rulefit.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />







<!-- Global site tag (gtag.js) - Google Analytics -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-110543840-1', 'https://christophm.github.io/interpretable-ml-book/', {
  'anonymizeIp': true
  , 'storage': 'none'
  , 'clientId': window.localStorage.getItem('ga_clientId')
});
ga(function(tracker) {
  window.localStorage.setItem('ga_clientId', tracker.get('clientId'));
});
ga('send', 'pageview');
</script>

<link rel="stylesheet" type="text/css" href="css/cookieconsent.min.css" />
<script src="javascript/cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#000"
    },
    "button": {
      "background": "#f1d600"
    }
  },
  "position": "bottom-right",
  "content": {
    "message": "This website uses cookies for Google Analytics so that I know how many people are reading the book and which chapters are the most popular. The book website doesn't collect any personal data."
  }
})});
</script>



<link rel="stylesheet" href="css/style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Interpretable machine learning</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> Preface</a></li>
<li class="chapter" data-level="2" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>2</b> Introduction</a><ul>
<li class="chapter" data-level="2.1" data-path="storytime.html"><a href="storytime.html"><i class="fa fa-check"></i><b>2.1</b> Storytime</a><ul>
<li class="chapter" data-level="" data-path="storytime.html"><a href="storytime.html#lightning-never-strikes-twice"><i class="fa fa-check"></i>Lightning Never Strikes Twice</a></li>
<li class="chapter" data-level="" data-path="storytime.html"><a href="storytime.html#trust-fall"><i class="fa fa-check"></i>Trust Fall</a></li>
<li class="chapter" data-level="" data-path="storytime.html"><a href="storytime.html#fermis-paperclips"><i class="fa fa-check"></i>Fermi’s Paperclips</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="what-is-machine-learning.html"><a href="what-is-machine-learning.html"><i class="fa fa-check"></i><b>2.2</b> What Is Machine Learning?</a></li>
<li class="chapter" data-level="2.3" data-path="definitions.html"><a href="definitions.html"><i class="fa fa-check"></i><b>2.3</b> Definitions</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="interpretability.html"><a href="interpretability.html"><i class="fa fa-check"></i><b>3</b> Interpretability</a><ul>
<li class="chapter" data-level="3.1" data-path="interpretability-importance.html"><a href="interpretability-importance.html"><i class="fa fa-check"></i><b>3.1</b> The Importance of Interpretability</a></li>
<li class="chapter" data-level="3.2" data-path="criteria-for-interpretability-methods.html"><a href="criteria-for-interpretability-methods.html"><i class="fa fa-check"></i><b>3.2</b> Criteria for Interpretability Methods</a></li>
<li class="chapter" data-level="3.3" data-path="scope-of-interpretability.html"><a href="scope-of-interpretability.html"><i class="fa fa-check"></i><b>3.3</b> Scope of Interpretability</a><ul>
<li class="chapter" data-level="3.3.1" data-path="scope-of-interpretability.html"><a href="scope-of-interpretability.html#algorithm-transparency"><i class="fa fa-check"></i><b>3.3.1</b> Algorithm transparency</a></li>
<li class="chapter" data-level="3.3.2" data-path="scope-of-interpretability.html"><a href="scope-of-interpretability.html#global-holistic-model-interpretability"><i class="fa fa-check"></i><b>3.3.2</b> Global, Holistic Model Interpretability</a></li>
<li class="chapter" data-level="3.3.3" data-path="scope-of-interpretability.html"><a href="scope-of-interpretability.html#global-model-interpretability-on-a-modular-level"><i class="fa fa-check"></i><b>3.3.3</b> Global Model Interpretability on a Modular Level</a></li>
<li class="chapter" data-level="3.3.4" data-path="scope-of-interpretability.html"><a href="scope-of-interpretability.html#local-interpretability-for-a-single-prediction"><i class="fa fa-check"></i><b>3.3.4</b> Local Interpretability for a Single Prediction</a></li>
<li class="chapter" data-level="3.3.5" data-path="scope-of-interpretability.html"><a href="scope-of-interpretability.html#local-interpretability-for-a-group-of-predictions"><i class="fa fa-check"></i><b>3.3.5</b> Local Interpretability for a Group of Predictions</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="evaluating-interpretability.html"><a href="evaluating-interpretability.html"><i class="fa fa-check"></i><b>3.4</b> Evaluating Interpretability</a></li>
<li class="chapter" data-level="3.5" data-path="explanation.html"><a href="explanation.html"><i class="fa fa-check"></i><b>3.5</b> Human-friendly Explanations</a><ul>
<li class="chapter" data-level="3.5.1" data-path="explanation.html"><a href="explanation.html#what-is-an-explanation"><i class="fa fa-check"></i><b>3.5.1</b> What is an explanation?</a></li>
<li class="chapter" data-level="3.5.2" data-path="explanation.html"><a href="explanation.html#good-explanation"><i class="fa fa-check"></i><b>3.5.2</b> What is a “good” explanation?</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="data.html"><a href="data.html"><i class="fa fa-check"></i><b>4</b> Datasets</a><ul>
<li class="chapter" data-level="4.1" data-path="bike-data.html"><a href="bike-data.html"><i class="fa fa-check"></i><b>4.1</b> Bike Sharing Counts (Regression)</a></li>
<li class="chapter" data-level="4.2" data-path="spam-data.html"><a href="spam-data.html"><i class="fa fa-check"></i><b>4.2</b> YouTube Spam Comments (Text Classification)</a></li>
<li class="chapter" data-level="4.3" data-path="cervical.html"><a href="cervical.html"><i class="fa fa-check"></i><b>4.3</b> Risk Factors for Cervical Cancer (Classification)</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="simple.html"><a href="simple.html"><i class="fa fa-check"></i><b>5</b> Interpretable Models</a><ul>
<li class="chapter" data-level="5.1" data-path="limo.html"><a href="limo.html"><i class="fa fa-check"></i><b>5.1</b> Linear Model</a><ul>
<li class="chapter" data-level="5.1.1" data-path="limo.html"><a href="limo.html#interpretation"><i class="fa fa-check"></i><b>5.1.1</b> Interpretation</a></li>
<li class="chapter" data-level="5.1.2" data-path="limo.html"><a href="limo.html#interpretation-example"><i class="fa fa-check"></i><b>5.1.2</b> Interpretation Example</a></li>
<li class="chapter" data-level="5.1.3" data-path="limo.html"><a href="limo.html#interpretation-templates"><i class="fa fa-check"></i><b>5.1.3</b> Interpretation templates</a></li>
<li class="chapter" data-level="5.1.4" data-path="limo.html"><a href="limo.html#visual-parameter-interpretation"><i class="fa fa-check"></i><b>5.1.4</b> Visual parameter interpretation</a></li>
<li class="chapter" data-level="5.1.5" data-path="limo.html"><a href="limo.html#explaining-single-predictions"><i class="fa fa-check"></i><b>5.1.5</b> Explaining Single Predictions</a></li>
<li class="chapter" data-level="5.1.6" data-path="limo.html"><a href="limo.html#cat-code"><i class="fa fa-check"></i><b>5.1.6</b> Coding Categorical Features</a></li>
<li class="chapter" data-level="5.1.7" data-path="limo.html"><a href="limo.html#the-disadvantages-of-linear-models"><i class="fa fa-check"></i><b>5.1.7</b> The disadvantages of linear models</a></li>
<li class="chapter" data-level="5.1.8" data-path="limo.html"><a href="limo.html#do-linear-models-create-good-explanations"><i class="fa fa-check"></i><b>5.1.8</b> Do linear models create good explanations?</a></li>
<li class="chapter" data-level="5.1.9" data-path="limo.html"><a href="limo.html#extending-linear-models"><i class="fa fa-check"></i><b>5.1.9</b> Extending Linear Models</a></li>
<li class="chapter" data-level="5.1.10" data-path="limo.html"><a href="limo.html#sparse-linear"><i class="fa fa-check"></i><b>5.1.10</b> Sparse linear models</a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="logistic.html"><a href="logistic.html"><i class="fa fa-check"></i><b>5.2</b> Logistic Regression</a><ul>
<li class="chapter" data-level="5.2.1" data-path="logistic.html"><a href="logistic.html#whats-wrong-with-linear-regression-models-for-classification"><i class="fa fa-check"></i><b>5.2.1</b> What’s Wrong with Linear Regression Models for Classification?</a></li>
<li class="chapter" data-level="5.2.2" data-path="logistic.html"><a href="logistic.html#logistic-regression"><i class="fa fa-check"></i><b>5.2.2</b> Logistic Regression</a></li>
<li class="chapter" data-level="5.2.3" data-path="logistic.html"><a href="logistic.html#interpretation-1"><i class="fa fa-check"></i><b>5.2.3</b> Interpretation</a></li>
<li class="chapter" data-level="5.2.4" data-path="logistic.html"><a href="logistic.html#example"><i class="fa fa-check"></i><b>5.2.4</b> Example</a></li>
</ul></li>
<li class="chapter" data-level="5.3" data-path="tree.html"><a href="tree.html"><i class="fa fa-check"></i><b>5.3</b> Decision Tree</a><ul>
<li class="chapter" data-level="5.3.1" data-path="tree.html"><a href="tree.html#interpretation-2"><i class="fa fa-check"></i><b>5.3.1</b> Interpretation</a></li>
<li class="chapter" data-level="5.3.2" data-path="tree.html"><a href="tree.html#interpretation-example-1"><i class="fa fa-check"></i><b>5.3.2</b> Interpretation Example</a></li>
<li class="chapter" data-level="5.3.3" data-path="tree.html"><a href="tree.html#advantages"><i class="fa fa-check"></i><b>5.3.3</b> Advantages</a></li>
<li class="chapter" data-level="5.3.4" data-path="tree.html"><a href="tree.html#disadvantages"><i class="fa fa-check"></i><b>5.3.4</b> Disadvantages</a></li>
</ul></li>
<li class="chapter" data-level="5.4" data-path="rules.html"><a href="rules.html"><i class="fa fa-check"></i><b>5.4</b> Decision Rules (IF-THEN)</a><ul>
<li class="chapter" data-level="5.4.1" data-path="rules.html"><a href="rules.html#learn-rules-from-a-single-feature-oner"><i class="fa fa-check"></i><b>5.4.1</b> Learn Rules from a Single Feature (OneR)</a></li>
<li class="chapter" data-level="5.4.2" data-path="rules.html"><a href="rules.html#sequential-covering"><i class="fa fa-check"></i><b>5.4.2</b> Sequential Covering</a></li>
<li class="chapter" data-level="5.4.3" data-path="rules.html"><a href="rules.html#bayesian-rule-lists"><i class="fa fa-check"></i><b>5.4.3</b> Bayesian Rule Lists</a></li>
<li class="chapter" data-level="5.4.4" data-path="rules.html"><a href="rules.html#advantages-1"><i class="fa fa-check"></i><b>5.4.4</b> Advantages</a></li>
<li class="chapter" data-level="5.4.5" data-path="rules.html"><a href="rules.html#disadvantages-1"><i class="fa fa-check"></i><b>5.4.5</b> Disadvantages</a></li>
<li class="chapter" data-level="5.4.6" data-path="rules.html"><a href="rules.html#software-and-alternatives"><i class="fa fa-check"></i><b>5.4.6</b> Software and Alternatives</a></li>
</ul></li>
<li class="chapter" data-level="5.5" data-path="rulefit.html"><a href="rulefit.html"><i class="fa fa-check"></i><b>5.5</b> RuleFit</a><ul>
<li class="chapter" data-level="5.5.1" data-path="rulefit.html"><a href="rulefit.html#interpretation-and-example"><i class="fa fa-check"></i><b>5.5.1</b> Interpretation and Example</a></li>
<li class="chapter" data-level="5.5.2" data-path="rulefit.html"><a href="rulefit.html#guidelines"><i class="fa fa-check"></i><b>5.5.2</b> Guidelines</a></li>
<li class="chapter" data-level="5.5.3" data-path="rulefit.html"><a href="rulefit.html#theory"><i class="fa fa-check"></i><b>5.5.3</b> Theory</a></li>
</ul></li>
<li class="chapter" data-level="5.6" data-path="other-interpretable.html"><a href="other-interpretable.html"><i class="fa fa-check"></i><b>5.6</b> Other Interpretable Models</a><ul>
<li class="chapter" data-level="5.6.1" data-path="other-interpretable.html"><a href="other-interpretable.html#naive-bayes-classifier"><i class="fa fa-check"></i><b>5.6.1</b> Naive Bayes classifier</a></li>
<li class="chapter" data-level="5.6.2" data-path="other-interpretable.html"><a href="other-interpretable.html#k-nearest-neighbours"><i class="fa fa-check"></i><b>5.6.2</b> K-Nearest Neighbours</a></li>
<li class="chapter" data-level="5.6.3" data-path="other-interpretable.html"><a href="other-interpretable.html#and-so-many-more"><i class="fa fa-check"></i><b>5.6.3</b> And so many more …</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="6" data-path="agnostic.html"><a href="agnostic.html"><i class="fa fa-check"></i><b>6</b> Model-Agnostic Methods</a><ul>
<li class="chapter" data-level="6.1" data-path="pdp.html"><a href="pdp.html"><i class="fa fa-check"></i><b>6.1</b> Partial Dependence Plot (PDP)</a><ul>
<li class="chapter" data-level="6.1.1" data-path="pdp.html"><a href="pdp.html#examples"><i class="fa fa-check"></i><b>6.1.1</b> Examples</a></li>
<li class="chapter" data-level="6.1.2" data-path="pdp.html"><a href="pdp.html#advantages-2"><i class="fa fa-check"></i><b>6.1.2</b> Advantages</a></li>
<li class="chapter" data-level="6.1.3" data-path="pdp.html"><a href="pdp.html#disadvantages-2"><i class="fa fa-check"></i><b>6.1.3</b> Disadvantages</a></li>
</ul></li>
<li class="chapter" data-level="6.2" data-path="ice.html"><a href="ice.html"><i class="fa fa-check"></i><b>6.2</b> Individual Conditional Expectation (ICE)</a><ul>
<li class="chapter" data-level="6.2.1" data-path="ice.html"><a href="ice.html#example-1"><i class="fa fa-check"></i><b>6.2.1</b> Example</a></li>
<li class="chapter" data-level="6.2.2" data-path="ice.html"><a href="ice.html#advantages-3"><i class="fa fa-check"></i><b>6.2.2</b> Advantages</a></li>
<li class="chapter" data-level="6.2.3" data-path="ice.html"><a href="ice.html#disadvantages-3"><i class="fa fa-check"></i><b>6.2.3</b> Disadvantages</a></li>
</ul></li>
<li class="chapter" data-level="6.3" data-path="ale.html"><a href="ale.html"><i class="fa fa-check"></i><b>6.3</b> Accumulated Local Effects (ALE) Plot</a><ul>
<li class="chapter" data-level="6.3.1" data-path="ale.html"><a href="ale.html#motivation-and-intuition"><i class="fa fa-check"></i><b>6.3.1</b> Motivation and Intuition</a></li>
<li class="chapter" data-level="6.3.2" data-path="ale.html"><a href="ale.html#theory-1"><i class="fa fa-check"></i><b>6.3.2</b> Theory</a></li>
<li class="chapter" data-level="6.3.3" data-path="ale.html"><a href="ale.html#estimation"><i class="fa fa-check"></i><b>6.3.3</b> Estimation</a></li>
<li class="chapter" data-level="6.3.4" data-path="ale.html"><a href="ale.html#examples-1"><i class="fa fa-check"></i><b>6.3.4</b> Examples</a></li>
<li class="chapter" data-level="6.3.5" data-path="ale.html"><a href="ale.html#advantages-4"><i class="fa fa-check"></i><b>6.3.5</b> Advantages</a></li>
<li class="chapter" data-level="6.3.6" data-path="ale.html"><a href="ale.html#disadvantages-4"><i class="fa fa-check"></i><b>6.3.6</b> Disadvantages</a></li>
<li class="chapter" data-level="6.3.7" data-path="ale.html"><a href="ale.html#implementation-and-alternatives"><i class="fa fa-check"></i><b>6.3.7</b> Implementation and Alternatives</a></li>
</ul></li>
<li class="chapter" data-level="6.4" data-path="interaction.html"><a href="interaction.html"><i class="fa fa-check"></i><b>6.4</b> Feature Interaction</a><ul>
<li class="chapter" data-level="6.4.1" data-path="interaction.html"><a href="interaction.html#feature-interaction"><i class="fa fa-check"></i><b>6.4.1</b> Feature Interaction?</a></li>
<li class="chapter" data-level="6.4.2" data-path="interaction.html"><a href="interaction.html#theory-friedmans-h-statistic"><i class="fa fa-check"></i><b>6.4.2</b> Theory: Friedman’s H-statistic</a></li>
<li class="chapter" data-level="6.4.3" data-path="interaction.html"><a href="interaction.html#examples-2"><i class="fa fa-check"></i><b>6.4.3</b> Examples</a></li>
<li class="chapter" data-level="6.4.4" data-path="interaction.html"><a href="interaction.html#advantages-5"><i class="fa fa-check"></i><b>6.4.4</b> Advantages</a></li>
<li class="chapter" data-level="6.4.5" data-path="interaction.html"><a href="interaction.html#disadvantages-5"><i class="fa fa-check"></i><b>6.4.5</b> Disadvantages</a></li>
<li class="chapter" data-level="6.4.6" data-path="interaction.html"><a href="interaction.html#implementations"><i class="fa fa-check"></i><b>6.4.6</b> Implementations</a></li>
<li class="chapter" data-level="6.4.7" data-path="interaction.html"><a href="interaction.html#alternatives"><i class="fa fa-check"></i><b>6.4.7</b> Alternatives</a></li>
</ul></li>
<li class="chapter" data-level="6.5" data-path="feature-importance.html"><a href="feature-importance.html"><i class="fa fa-check"></i><b>6.5</b> Feature Importance</a><ul>
<li class="chapter" data-level="6.5.1" data-path="feature-importance.html"><a href="feature-importance.html#the-theory"><i class="fa fa-check"></i><b>6.5.1</b> The Theory</a></li>
<li class="chapter" data-level="6.5.2" data-path="feature-importance.html"><a href="feature-importance.html#example-and-interpretation"><i class="fa fa-check"></i><b>6.5.2</b> Example and Interpretation</a></li>
<li class="chapter" data-level="6.5.3" data-path="feature-importance.html"><a href="feature-importance.html#advantages-6"><i class="fa fa-check"></i><b>6.5.3</b> Advantages</a></li>
<li class="chapter" data-level="6.5.4" data-path="feature-importance.html"><a href="feature-importance.html#disadvantages-6"><i class="fa fa-check"></i><b>6.5.4</b> Disadvantages</a></li>
</ul></li>
<li class="chapter" data-level="6.6" data-path="global.html"><a href="global.html"><i class="fa fa-check"></i><b>6.6</b> Global Surrogate Models</a><ul>
<li class="chapter" data-level="6.6.1" data-path="global.html"><a href="global.html#theory-2"><i class="fa fa-check"></i><b>6.6.1</b> Theory</a></li>
<li class="chapter" data-level="6.6.2" data-path="global.html"><a href="global.html#example-3"><i class="fa fa-check"></i><b>6.6.2</b> Example</a></li>
<li class="chapter" data-level="6.6.3" data-path="global.html"><a href="global.html#advantages-7"><i class="fa fa-check"></i><b>6.6.3</b> Advantages</a></li>
<li class="chapter" data-level="6.6.4" data-path="global.html"><a href="global.html#disadvantages-7"><i class="fa fa-check"></i><b>6.6.4</b> Disadvantages</a></li>
</ul></li>
<li class="chapter" data-level="6.7" data-path="lime.html"><a href="lime.html"><i class="fa fa-check"></i><b>6.7</b> Local Surrogate Models (LIME)</a><ul>
<li class="chapter" data-level="6.7.1" data-path="lime.html"><a href="lime.html#lime-for-tabular-data"><i class="fa fa-check"></i><b>6.7.1</b> LIME for Tabular Data</a></li>
<li class="chapter" data-level="6.7.2" data-path="lime.html"><a href="lime.html#lime-for-text"><i class="fa fa-check"></i><b>6.7.2</b> LIME for Text</a></li>
<li class="chapter" data-level="6.7.3" data-path="lime.html"><a href="lime.html#images-lime"><i class="fa fa-check"></i><b>6.7.3</b> LIME for Images</a></li>
</ul></li>
<li class="chapter" data-level="6.8" data-path="shapley.html"><a href="shapley.html"><i class="fa fa-check"></i><b>6.8</b> Shapley Value Explanations</a><ul>
<li class="chapter" data-level="6.8.1" data-path="shapley.html"><a href="shapley.html#the-general-idea"><i class="fa fa-check"></i><b>6.8.1</b> The general idea</a></li>
<li class="chapter" data-level="6.8.2" data-path="shapley.html"><a href="shapley.html#examples-and-interpretation"><i class="fa fa-check"></i><b>6.8.2</b> Examples and Interpretation</a></li>
<li class="chapter" data-level="6.8.3" data-path="shapley.html"><a href="shapley.html#the-shapley-value-in-detail"><i class="fa fa-check"></i><b>6.8.3</b> The Shapley Value in Detail</a></li>
<li class="chapter" data-level="6.8.4" data-path="shapley.html"><a href="shapley.html#advantages-8"><i class="fa fa-check"></i><b>6.8.4</b> Advantages</a></li>
<li class="chapter" data-level="6.8.5" data-path="shapley.html"><a href="shapley.html#disadvantages-8"><i class="fa fa-check"></i><b>6.8.5</b> Disadvantages</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="7" data-path="example-based.html"><a href="example-based.html"><i class="fa fa-check"></i><b>7</b> Example-based Explanations</a><ul>
<li class="chapter" data-level="7.1" data-path="counterfactual.html"><a href="counterfactual.html"><i class="fa fa-check"></i><b>7.1</b> Counterfactual explanations</a><ul>
<li class="chapter" data-level="7.1.1" data-path="counterfactual.html"><a href="counterfactual.html#generating-counterfactual-explanations"><i class="fa fa-check"></i><b>7.1.1</b> Generating counterfactual explanations</a></li>
<li class="chapter" data-level="7.1.2" data-path="counterfactual.html"><a href="counterfactual.html#examples-3"><i class="fa fa-check"></i><b>7.1.2</b> Examples</a></li>
<li class="chapter" data-level="7.1.3" data-path="counterfactual.html"><a href="counterfactual.html#advantages-9"><i class="fa fa-check"></i><b>7.1.3</b> Advantages</a></li>
<li class="chapter" data-level="7.1.4" data-path="counterfactual.html"><a href="counterfactual.html#disadvantages-9"><i class="fa fa-check"></i><b>7.1.4</b> Disadvantages</a></li>
<li class="chapter" data-level="7.1.5" data-path="counterfactual.html"><a href="counterfactual.html#example-software"><i class="fa fa-check"></i><b>7.1.5</b> Software and Alternatives</a></li>
</ul></li>
<li class="chapter" data-level="7.2" data-path="adversarial.html"><a href="adversarial.html"><i class="fa fa-check"></i><b>7.2</b> Adversarial Examples</a><ul>
<li class="chapter" data-level="7.2.1" data-path="adversarial.html"><a href="adversarial.html#methods-and-examples"><i class="fa fa-check"></i><b>7.2.1</b> Methods and Examples</a></li>
<li class="chapter" data-level="7.2.2" data-path="adversarial.html"><a href="adversarial.html#the-cybersecurity-perspective"><i class="fa fa-check"></i><b>7.2.2</b> The Cybersecurity Perspective</a></li>
</ul></li>
<li class="chapter" data-level="7.3" data-path="proto.html"><a href="proto.html"><i class="fa fa-check"></i><b>7.3</b> Prototypes and Criticisms</a><ul>
<li class="chapter" data-level="7.3.1" data-path="proto.html"><a href="proto.html#theory-3"><i class="fa fa-check"></i><b>7.3.1</b> Theory</a></li>
<li class="chapter" data-level="7.3.2" data-path="proto.html"><a href="proto.html#examples-4"><i class="fa fa-check"></i><b>7.3.2</b> Examples</a></li>
<li class="chapter" data-level="7.3.3" data-path="proto.html"><a href="proto.html#advantages-10"><i class="fa fa-check"></i><b>7.3.3</b> Advantages</a></li>
<li class="chapter" data-level="7.3.4" data-path="proto.html"><a href="proto.html#disadvantages-10"><i class="fa fa-check"></i><b>7.3.4</b> Disadvantages</a></li>
<li class="chapter" data-level="7.3.5" data-path="proto.html"><a href="proto.html#code-and-alternatives"><i class="fa fa-check"></i><b>7.3.5</b> Code and Alternatives</a></li>
</ul></li>
<li class="chapter" data-level="7.4" data-path="influential.html"><a href="influential.html"><i class="fa fa-check"></i><b>7.4</b> Influential Instances</a><ul>
<li class="chapter" data-level="7.4.1" data-path="influential.html"><a href="influential.html#deletion-diagnostics"><i class="fa fa-check"></i><b>7.4.1</b> Deletion Diagnostics</a></li>
<li class="chapter" data-level="7.4.2" data-path="influential.html"><a href="influential.html#influence-functions"><i class="fa fa-check"></i><b>7.4.2</b> Influence Functions</a></li>
<li class="chapter" data-level="7.4.3" data-path="influential.html"><a href="influential.html#advantages-of-identifying-influential-instances"><i class="fa fa-check"></i><b>7.4.3</b> Advantages of Identifying Influential Instances</a></li>
<li class="chapter" data-level="7.4.4" data-path="influential.html"><a href="influential.html#disadvantages-of-identifying-influential-instances"><i class="fa fa-check"></i><b>7.4.4</b> Disadvantages of Identifying Influential Instances</a></li>
<li class="chapter" data-level="7.4.5" data-path="influential.html"><a href="influential.html#software-and-alternatives-1"><i class="fa fa-check"></i><b>7.4.5</b> Software and Alternatives</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="8" data-path="future.html"><a href="future.html"><i class="fa fa-check"></i><b>8</b> A Look into the Crystal Ball</a><ul>
<li class="chapter" data-level="8.1" data-path="the-future-of-machine-learning.html"><a href="the-future-of-machine-learning.html"><i class="fa fa-check"></i><b>8.1</b> The Future of Machine Learning</a></li>
<li class="chapter" data-level="8.2" data-path="the-future-of-interpretability.html"><a href="the-future-of-interpretability.html"><i class="fa fa-check"></i><b>8.2</b> The Future of Interpretability</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="contribute.html"><a href="contribute.html"><i class="fa fa-check"></i><b>9</b> Contribute</a></li>
<li class="chapter" data-level="10" data-path="citation.html"><a href="citation.html"><i class="fa fa-check"></i><b>10</b> Citation</a></li>
<li class="chapter" data-level="11" data-path="acknowledgements.html"><a href="acknowledgements.html"><i class="fa fa-check"></i><b>11</b> Acknowledgements</a></li>
<li class="divider"></li>
<li><a href="https://bookdown.org" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Interpretable Machine Learning</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="rules" class="section level2">
<h2><span class="header-section-number">5.4</span> Decision Rules (IF-THEN)</h2>
<p>A decision rule is a simple IF-THEN statement consisting of a condition (also called antecedent) and a prediction.
For example:
IF it rains today AND if it’s April (condition), THEN it will rain tomorrow (prediction).
A single decision rule or a combination of several rules can be used to make predictions.</p>
<p><em>Keywords: decision rules, decision sets, decision lists, association rules, IF-THEN rules</em></p>
<p>Decision rules follow a general structure:
IF the condition is true THEN make a particular prediction.
Decision rules are probably the most interpretable prediction models.
Their IF-THEN structure semantically resembles natural language and the way we think, provided that the condition is built from intelligible features, the length of the condition is short (number of <span class="math inline">\(feature=value\)</span> pairs combined with an AND) and there are not too many rules.
In programming it’s very natural to write IF-THEN rules.
New in machine learning is that the decision rules are learned through an algorithm.</p>
<p>Imagine using an algorithm to learn decision rules for predicting the value of a house (<span class="math inline">\(low\)</span>, <span class="math inline">\(medium\)</span> or <span class="math inline">\(high\)</span>).
One decision rule learned by this model could be:
If a house is bigger than 100 square meters and has a garden, then its value is high.
More formally:
IF <span class="math inline">\(size&gt;100\land{}garden=1\)</span> THEN <span class="math inline">\(value=high\)</span>.
Sometimes decision rules are also written like this:
<span class="math inline">\((size&gt;100)\land(garden=1)\Rightarrow{}(value=high)\)</span>.</p>
<p>Let’s break down the decision rule:</p>
<ul>
<li><span class="math inline">\(size&gt;100\)</span> is the first condition in the IF-part.</li>
<li><span class="math inline">\(garden=1\)</span> is the second condition in the IF-part.</li>
<li>The two conditions are connected with an ‘AND’ to create a new condition.
Both must be true for the rule to apply.</li>
<li>The predicted outcome (THEN-part) is that <span class="math inline">\(value=high\)</span>.</li>
</ul>
<p>A decision rule uses at least one <span class="math inline">\(feature=value\)</span> statement in the condition, with no upper limit on how many more can be added with an ‘AND’.
An exception is the default rule that has no explicit IF-part and that applies when no other rule applies, but more about this later.</p>
<p>How do we assess whether a particular decision rule makes sense?
The usefulness of a decision rule is usually summarized in two numbers: Support and accuracy.</p>
<p><strong>Support (or coverage) of a rule</strong>:
The percentage of instances to which the condition of a rule applies is called the support.
Take for example the rule <span class="math inline">\((size=big)\land(location=good)\Rightarrow(value=high)\)</span> for predicting house values.
Suppose 100 of 1000 houses are big and in a good location, then the support of the rule is 10%.
The prediction (THEN-part) is not important for the calculation of support.</p>
<p><strong>Accuracy (or confidence) of a rule</strong>:
The accuracy of a rule is a measure of how accurate the rule is in predicting the correct class for the instances to which the condition of the rule applies.
For example:
Let’s say of the 100 houses, where the rule <span class="math inline">\((size=big)\land(location=good)\Rightarrow(value=high)\)</span> applies, 85 have <span class="math inline">\(value=high\)</span>, 14 <span class="math inline">\(value=medium\)</span> and 1 <span class="math inline">\(value=low\)</span>, then the accuracy of the rule is 85%.</p>
<p>Usually there is a trade-off between accuracy and support:
By adding more features in the condition, we can achieve higher accuracy, but lose support.</p>
<p>To create a good classifier for predicting the value of a house you might need to learn not only one rule, but maybe 10 or 20.
Then things can get more complicated:</p>
<ul>
<li>Rules can overlap:
What if I want to predict the value of a house and two or more rules apply and they give me contradictory predictions?</li>
<li>No rule applies:
What if I want to predict the value of a house and none of the rules apply?</li>
</ul>
<p>There are two main strategies for dealing with multiple rules:
Decision lists (ordered) and decision sets (unordered).
Both strategies imply different solutions to the problem of overlapping rules.</p>
<p>A <strong>decision list</strong> introduces an order to the decision rules.
If the condition of the first rule is true for an instance, we use the prediction of the first rule.
If not, we go to the next rule and check if it is true and so on.
Decision lists are one-sided decision trees, where the first rule is the root node and with each rule, the tree grows in one direction.
Decision lists solve the problem of overlapping rules by only returning the prediction of the first rule in the list that applies.</p>
<p>A <strong>decision set</strong> resembles a democracy of the rules, except that some rules might have a higher voting power.
In a set, the rules are either mutually exclusive, or there is a strategy for resolving conflicts, such as majority voting, which may be weighted by the individual rule accuracies or other quality measures.
Interpretability suffers potentially when several rules apply.</p>
<p>Both decision lists and sets can suffer from the problem that no rule applies to an instance.
This can be resolved by introducing a default rule.
The default rule is the rule that applies when no other rule applies.
The prediction of the default rule is often the most frequent class of the data points which are not covered by other rules.
If a set or list of rules covers the entire feature space, we call it exhaustive.
By adding a default rule, a set or list automatically becomes exhaustive.</p>
<p>There are many ways to learn rules from data and this book is far from covering them all.
This chapter shows you three of them.
The algorithms are chosen to cover a wide range of general ideas for learning rules, so all three of them represent very different approaches.</p>
<ol style="list-style-type: decimal">
<li><strong>OneR</strong> learns rules from a single feature.
OneR is characterized by its simplicity, interpretability and its use as a benchmark.</li>
<li><strong>Sequential covering</strong> is a general procedure that iteratively learns rules and removes the data points that are covered by the new rule.
This procedure is used by many rule learning algorithms.</li>
<li><strong>Bayesian Rule Lists</strong> combine pre-mined frequent patterns into a decision list using Bayesian statistics.
Using pre-mined patterns is a common approach used by many rule learning algorithms.</li>
</ol>
<p>Let’s start with the simplest approach: Using the single, best feature to learn rules.</p>
<div id="learn-rules-from-a-single-feature-oner" class="section level3">
<h3><span class="header-section-number">5.4.1</span> Learn Rules from a Single Feature (OneR)</h3>
<p>The OneR algorithm is one of the simplest rule induction algorithm.
From all the features, OneR selects the one that carries the most information about the outcome of interest and creates decision rules from this feature.</p>
<p>Despite the name OneR, which stands for “One Rule”, the algorithm generates more than one rule:
It’s actually one rule per unique feature value of the selected best feature.
A better name would be OneFeatureRules.</p>
<p>The algorithm is simple and fast:</p>
<ol style="list-style-type: decimal">
<li>Discretize the continuous features by choosing appropriate intervals.</li>
<li>For each feature <span class="math inline">\(x_j\)</span>:
<ul>
<li>Create a cross table between the feature values and the (categorical) outcome.</li>
<li>For each feature values of <span class="math inline">\(x_j\)</span>, create a rule which predicts the most frequent class of the instances that have this particular feature value (can be read from the cross table).</li>
<li>Calculate the total error of the rules for feature <span class="math inline">\(x_j\)</span>.</li>
</ul></li>
<li>Select the feature with the smallest total error.</li>
</ol>
<p>OneR always covers all instances of the dataset, since it uses all levels of the selected feature.
Missing values can be either treated as an additional feature value or be imputed beforehand.</p>
<p>OneR can be considered as a decision tree with only one split.
The split is not necessarily binary as in CART, but depends on the number of unique feature values.</p>
<p>Let’s look at an example how the best feature is chosen by OneR.
The following table shows an artificial dataset about houses with information about its value, location, size and whether pets are allowed.
We are interested in learning a simple model to predict the value of a house.</p>
<table>
<thead>
<tr class="header">
<th align="left">location</th>
<th align="left">size</th>
<th align="left">pets</th>
<th align="left">value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">good</td>
<td align="left">small</td>
<td align="left">yes</td>
<td align="left">high</td>
</tr>
<tr class="even">
<td align="left">good</td>
<td align="left">big</td>
<td align="left">no</td>
<td align="left">high</td>
</tr>
<tr class="odd">
<td align="left">good</td>
<td align="left">big</td>
<td align="left">no</td>
<td align="left">high</td>
</tr>
<tr class="even">
<td align="left">bad</td>
<td align="left">medium</td>
<td align="left">no</td>
<td align="left">medium</td>
</tr>
<tr class="odd">
<td align="left">good</td>
<td align="left">medium</td>
<td align="left">only cats</td>
<td align="left">medium</td>
</tr>
<tr class="even">
<td align="left">good</td>
<td align="left">small</td>
<td align="left">only cats</td>
<td align="left">medium</td>
</tr>
<tr class="odd">
<td align="left">bad</td>
<td align="left">medium</td>
<td align="left">yes</td>
<td align="left">medium</td>
</tr>
<tr class="even">
<td align="left">bad</td>
<td align="left">small</td>
<td align="left">yes</td>
<td align="left">low</td>
</tr>
<tr class="odd">
<td align="left">bad</td>
<td align="left">medium</td>
<td align="left">yes</td>
<td align="left">low</td>
</tr>
<tr class="even">
<td align="left">bad</td>
<td align="left">small</td>
<td align="left">no</td>
<td align="left">low</td>
</tr>
</tbody>
</table>
<p>OneR creates the cross tables between each feature and the outcome:</p>
<table>
<thead>
<tr class="header">
<th></th>
<th align="right">value=low</th>
<th align="right">value=medium</th>
<th align="right">value=high</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>location=bad</td>
<td align="right">3</td>
<td align="right">2</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>location=good</td>
<td align="right">0</td>
<td align="right">2</td>
<td align="right">3</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th></th>
<th align="right">value=low</th>
<th align="right">value=medium</th>
<th align="right">value=high</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>size=big</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">2</td>
</tr>
<tr class="even">
<td>size=medium</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td>size=small</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="right">1</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th></th>
<th align="right">value=low</th>
<th align="right">value=medium</th>
<th align="right">value=high</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>pets=no</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">2</td>
</tr>
<tr class="even">
<td>pets=only cats</td>
<td align="right">0</td>
<td align="right">2</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td>pets=yes</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="right">1</td>
</tr>
</tbody>
</table>
<p>For each feature, we go through the table row by row:
Each feature value is the IF-part of a rule;
the most common class for instances with this feature value is the prediction, the THEN-part of the rule.
For example, the size feature with the levels <span class="math inline">\(small\)</span>, <span class="math inline">\(medium\)</span> and <span class="math inline">\(big\)</span> results in three rules.
For each feature we calculate the total error rate of the generated rules, which is the sum of the errors.
The location feature has the possible values <span class="math inline">\(bad\)</span> and <span class="math inline">\(good\)</span>.
The most frequent value for houses in bad locations is <span class="math inline">\(low\)</span> and when we use <span class="math inline">\(low\)</span> as a prediction, we make two mistakes, because two houses have a <span class="math inline">\(medium\)</span> value.
The predicted price for houses in good locations is <span class="math inline">\(high\)</span> and again we make two mistakes, because two houses have a <span class="math inline">\(medium\)</span> value.
The error we make by of using the location feature is 4/10, for the size feature it’s 3/10 and for the pet feature it’s 4/10 .
The size feature produces the rules with the lowest error and will be used for the final OneR model:</p>
<ul>
<li>IF <span class="math inline">\(size=small\)</span> THEN <span class="math inline">\(value=small\)</span></li>
<li>IF <span class="math inline">\(size=medium\)</span> THEN <span class="math inline">\(value=medium\)</span></li>
<li>IF <span class="math inline">\(size=big\)</span> THEN <span class="math inline">\(value=high\)</span></li>
</ul>
<p>OneR prefers features with many possible levels, because those features can overfit the target more easily.
Imagine a dataset that contains only noise and no signal, which means that all features take on random values and have no predictive value for the target.
Some features have more levels than others.
The features with more levels can now more easily overfit.
A feature that has a separate level for each instance from the data would perfectly predict the entire training dataset.
A solution would be to split the data into training and validation sets, learn the rules on the training data and evaluate the total error for choosing the feature on the validation set.</p>
<p>Ties are another issues, i.e. when two features result in the same total error.
OneR solves ties by either taking the first feature with the lowest error or the one with the lowest p-value of a chi-squared test.</p>
<p>Let’s try OneR with real data.
We use the <a href="cervical.html#cervical">cervical cancer classification task</a> to test the OneR algorithm.
All continuous input features were divided into five intervals according to feature value frequency.
The following rules are created:</p>
<table>
<thead>
<tr class="header">
<th align="left">Age</th>
<th align="left">prediction</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">(12.9,27.2]</td>
<td align="left">Healthy</td>
</tr>
<tr class="even">
<td align="left">(27.2,41.4]</td>
<td align="left">Healthy</td>
</tr>
<tr class="odd">
<td align="left">(41.4,55.6]</td>
<td align="left">Healthy</td>
</tr>
<tr class="even">
<td align="left">(55.6,69.8]</td>
<td align="left">Healthy</td>
</tr>
<tr class="odd">
<td align="left">(69.8,84.1]</td>
<td align="left">Healthy</td>
</tr>
</tbody>
</table>
<p>The age feature was chosen by OneR as the best predictive feature.
Since <span class="math inline">\(Cancer\)</span> is rare, for each rule the majority class and therefore the predicted label is always <span class="math inline">\(Healthy\)</span>, which is rather unhelpful.
It does not make sense to use the label prediction in this unbalanced case.
The cross table between the ‘Age’ intervals and <span class="math inline">\(Cancer\)</span>/<span class="math inline">\(Healthy\)</span> together with the percentage of women with cancer is more informative:</p>
<table>
<thead>
<tr class="header">
<th></th>
<th align="right"># Cancer</th>
<th align="right"># Healthy</th>
<th align="right">P(Cancer)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Age=(12.9,27.2]</td>
<td align="right">26</td>
<td align="right">477</td>
<td align="right">0.05</td>
</tr>
<tr class="even">
<td>Age=(27.2,41.4]</td>
<td align="right">25</td>
<td align="right">290</td>
<td align="right">0.08</td>
</tr>
<tr class="odd">
<td>Age=(41.4,55.6]</td>
<td align="right">4</td>
<td align="right">31</td>
<td align="right">0.11</td>
</tr>
<tr class="even">
<td>Age=(55.6,69.8]</td>
<td align="right">0</td>
<td align="right">1</td>
<td align="right">0.00</td>
</tr>
<tr class="odd">
<td>Age=(69.8,84.1]</td>
<td align="right">0</td>
<td align="right">4</td>
<td align="right">0.00</td>
</tr>
</tbody>
</table>
<p>But before you start interpreting anything:
Since the prediction for every feature and every value is <span class="math inline">\(Healthy\)</span>, the total error rate is the same for all features.
The ties in the total error are, by default, resolved by using the first feature from the ones with the lowest error rates (here, all features have 55/858, which happens to be the Age feature.</p>
<p>OneR doesn’t support regression tasks directly.
But we can turn a regression task into a classification task by cutting the continuous outcome into intervals.
We use this trick to predict the number of <a href="#bike">rented bikes</a> with OneR by cutting the number of bikes into its four quartiles (0-25%, 25-50%, 50-75% and 75-100%).
The following table shows the selected feature after fitting the OneR model:</p>
<table>
<thead>
<tr class="header">
<th align="left">mnth</th>
<th align="left">prediction</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">JAN</td>
<td align="left">[22,3152]</td>
</tr>
<tr class="even">
<td align="left">FEB</td>
<td align="left">[22,3152]</td>
</tr>
<tr class="odd">
<td align="left">MAR</td>
<td align="left">[22,3152]</td>
</tr>
<tr class="even">
<td align="left">APR</td>
<td align="left">(3152,4548]</td>
</tr>
<tr class="odd">
<td align="left">MAY</td>
<td align="left">(5956,8714]</td>
</tr>
<tr class="even">
<td align="left">JUN</td>
<td align="left">(4548,5956]</td>
</tr>
<tr class="odd">
<td align="left">JUL</td>
<td align="left">(5956,8714]</td>
</tr>
<tr class="even">
<td align="left">AUG</td>
<td align="left">(5956,8714]</td>
</tr>
<tr class="odd">
<td align="left">SEP</td>
<td align="left">(5956,8714]</td>
</tr>
<tr class="even">
<td align="left">OKT</td>
<td align="left">(5956,8714]</td>
</tr>
<tr class="odd">
<td align="left">NOV</td>
<td align="left">(3152,4548]</td>
</tr>
<tr class="even">
<td align="left">DEZ</td>
<td align="left">[22,3152]</td>
</tr>
</tbody>
</table>
<p>The selected feature is the month.
The month feature has (surprise!) 12 feature levels, which is more than most other features have.
So there is a danger of overfitting.
On the more optimistic side: the month feature can handle the seasonal trend (e.g. less rented bikes in winter) and the predictions seem sensible.</p>
<p>Now we move from the simple OneR algorithm to a more complex procedure using rules with more complex conditions consisting of several features: Sequential Covering.</p>
</div>
<div id="sequential-covering" class="section level3">
<h3><span class="header-section-number">5.4.2</span> Sequential Covering</h3>
<p>Sequential covering is a general procedure that repeatedly learns a single rule to create a decision list (or set) that covers the entire dataset rule by rule.
Many rule-learning algorithms are variants of the sequential covering algorithm.
This chapter introduces the main recipe and uses RIPPER, a variant of the sequential covering algorithm for the examples.</p>
<p>The idea is simple:
First, find a good rule that applies to some of the data points.
Remove all data points which are covered by the rule, that is, each data point to which the condition applies, regardless of whether the points are classified correctly or not.
Repeat the rule-learning and removal of covered points with the remaining points until no more points are left or another stop condition is met.
The result is a decision list.
This approach of repeated rule-learning and removal of covered data points is called ‘separate-and-conquer’.</p>
<p>Suppose we already have an algorithm that can create a single rule that covers part of the data.
The sequential covering algorithm for two classes (one positive, one negative) works like this:</p>
<ul>
<li>Start with an empty list of rules (<span class="math inline">\(rlist\)</span>).</li>
<li>Learn a rule <span class="math inline">\(r\)</span>.</li>
<li>While the list of rules is below a quality threshold or some positive examples are not yet covered:
<ul>
<li>Add rule <span class="math inline">\(r\)</span> to <span class="math inline">\(rlist\)</span>.</li>
<li>Remove all data points covered by rule <span class="math inline">\(r\)</span>.</li>
<li>Learn another rule on the remaining data.</li>
</ul></li>
<li>Return the decision list.</li>
</ul>
<div class="figure"><span id="fig:covering-algo"></span>
<img src="images/covering-algo-1.png" alt="The covering algorithm works by sequentially covering the feature space with single rules and removing the data points that are already covered by those rules. The approach is called separate-and-conquer. For visualization purposes, the features x1 and x2 are continuous, but most rule learning algorithms require categorical features." width="1050" />
<p class="caption">
FIGURE 5.9: The covering algorithm works by sequentially covering the feature space with single rules and removing the data points that are already covered by those rules. The approach is called separate-and-conquer. For visualization purposes, the features x1 and x2 are continuous, but most rule learning algorithms require categorical features.
</p>
</div>
<p>For example:
We have a task and dataset for predicting the values of houses from size, location and whether pets are allowed.
We learn the first rule, which turns out to be:
‘If <span class="math inline">\(size=big\)</span> and <span class="math inline">\(location=good\)</span>, then <span class="math inline">\(value=high\)</span>’.
Then we remove all big houses in good locations from the dataset.
With the remaining data we learn the next rule:
Maybe: ‘If <span class="math inline">\(location=good\)</span>, then <span class="math inline">\(value=medium\)</span>’ (Note that this rule is learned on data without big houses in good locations, leaving only medium and small houses in good locations).</p>
<p>For multi-class settings, the approach must be modified.
First, the classes are ordered by increasing prevalence.
The sequential covering algorithm starts with the least common class, learns a rule for it, removes all covered instances, then moves on to the second least common class and so on.
The current class is always treated as the positive class and all classes with a higher prevalence as the negative class.
The last class is the default rule.
This is also referred to as one-versus-all strategy in classification.</p>
<p>How do we learn a single rule?
The OneR algorithm would be useless here, since it would always cover the whole feature space.
But there are many other possibilities.
One possibility is to learn a single rule from a decision tree with beam search:</p>
<ul>
<li>Learn a decision tree (with CART or another tree learning algorithm).</li>
<li>Start at the root node and recursively select the purest node (e.g. with the lowest misclassification rate).</li>
<li>The majority class of the node in which we end is used as the rule prediction;
the path leading to that node is used as the rule condition.</li>
</ul>
<p>The following figure illustrates the beam search in a tree:</p>
<div class="figure"><span id="fig:learn-one-rule"></span>
<img src="images/learn-one-rule.png" alt="Learning a rule by searching a path through a decision tree. A decision tree is grown to predict the target of interest. To extract a good rule, start at the root node, greedily and iteratively follow the path which locally produces the purest subset (e.g. with highest accuracy of target classes) and add all the split values to the rule condition. The prediction of the rule is the majority class of the node we land in. This example shows how we learn a rule for predicting the value of a house. We end up with: 'If $location=good$ and $size=big$, then $value=high$' (assuming high as the most common class in that terminal node)."  />
<p class="caption">
FIGURE 5.10: Learning a rule by searching a path through a decision tree. A decision tree is grown to predict the target of interest. To extract a good rule, start at the root node, greedily and iteratively follow the path which locally produces the purest subset (e.g. with highest accuracy of target classes) and add all the split values to the rule condition. The prediction of the rule is the majority class of the node we land in. This example shows how we learn a rule for predicting the value of a house. We end up with: ‘If <span class="math inline">\(location=good\)</span> and <span class="math inline">\(size=big\)</span>, then <span class="math inline">\(value=high\)</span>’ (assuming high as the most common class in that terminal node).
</p>
</div>
<p>Learning a single rule is equivalent to a search problem, where the search space is the space of all possible rules.
The goal of the search is to find the best rule according to some criteria.
There are many different search strategies:
hill-climbing, beam search, exhaustive search, best-first search, ordered search, stochastic search, top-down search, bottom-up search, …</p>
<p>RIPPER (Repeated Incremental Pruning to Produce Error Reduction) by Cohen (1995)<a href="#fn15" class="footnote-ref" id="fnref15"><sup>15</sup></a> is a variant of the Sequential Covering algorithm.
RIPPER is a bit more sophisticated and uses as post-processing phase (rule pruning) to optimize the decision list (or set).
RIPPER can run in ordered or unordered mode and generate either a decision list or decision set.</p>
<p>We will use RIPPER to predict our data examples.</p>
<p>The RIPPER algorithm does not find a rule in the classification task for <a href="cervical.html#cervical">cervical cancer</a>.
When we use RIPPER on the regression task to predict <a href="#bike">bike counts</a> some rules are found.
Since RIPPER only works for classification, the bike counts must be turned into a categorical outcome.
I achieved this by cutting the bike counts into the quartiles.
For example <span class="math inline">\((4548, 5956)\)</span> is the interval covering predicted bike counts between <span class="math inline">\(4548\)</span> and <span class="math inline">\(5956\)</span>.
The following table shows the learned rules.</p>
<p>The interpretation is simple:
If the conditions apply, we predict the interval on the right hand side as the number of bikes.
The last rule is the default rule that applies when none of the other rules apply to an instance.
To predict a new instance, start at the top of the list and check whether a rule applies.
When a condition matches, then the right hand side of the rule is the prediction for this instance.
The default rule ensures that there is always a prediction.</p>
</div>
<div id="bayesian-rule-lists" class="section level3">
<h3><span class="header-section-number">5.4.3</span> Bayesian Rule Lists</h3>
<p>In this section I will show you another approach to learning a decision list, which follows this rough recipe:</p>
<ol style="list-style-type: decimal">
<li>Pre-mine frequent patterns from the data that can be used as conditions for the decision rules.</li>
<li>Learn a decision list from a selection of the pre-mined rules.</li>
</ol>
<p>A specific approach using this recipe is called Bayesian Rule Lists (Letham et. al, 2015)<a href="#fn16" class="footnote-ref" id="fnref16"><sup>16</sup></a> or BRL for short.
BRL uses Bayesian statistics to learn decision lists from frequent patterns which are pre-mined with the FP-tree algorithm (Borgelt 2005)<a href="#fn17" class="footnote-ref" id="fnref17"><sup>17</sup></a></p>
<p>But let’s start slowly:</p>
<p><strong>Pre-mining of frequent patterns</strong></p>
<p>A frequent pattern is the frequent (co-)occurrence of feature values
As a pre-processing step for the BRL algorithm, we use the features (we don’t need the target outcome in this step) and extract frequently occurring patterns from them.
A pattern can be a single feature value (e.g. <span class="math inline">\(\text{size=medium}\)</span>) or a combination of feature values such as <span class="math inline">\(\text{size=medium}\land\text{location=bad}\)</span>.</p>
<p>The frequency of a pattern is measured with its support in the dataset:</p>
<p><span class="math display">\[Support(x_j=A)=\frac{1}n{}\sum_{i=1}^nI(x_{ji}=A)\]</span></p>
<p>where <span class="math inline">\(x_j=A\)</span> is the feature value, <span class="math inline">\(n\)</span> the number of data points in the dataset and <span class="math inline">\(I\)</span> the indicator function that returns <span class="math inline">\(1\)</span> if the feature <span class="math inline">\(x_j\)</span> of the instance <span class="math inline">\(i\)</span> has level <span class="math inline">\(A\)</span> otherwise <span class="math inline">\(0\)</span>.
In a dataset of house values, if 20% of houses have no balcony and 80% have one or more, then the support for the pattern <span class="math inline">\(balcony=0\)</span> is 20%.
Support can also be measured for combinations of feature values, for example for <span class="math inline">\(\text{balcony=0}\land\text{pets=allowed}\)</span>.</p>
<p>There are many algorithms to find such frequent patterns, for example Apriori or FP-Growth.
Which you use doesn’t matter much, only the speed at which the patterns are found is different, but the resulting patterns are always the same.</p>
<p>I’ll give you a rough idea of how the Apriori algorithm works to find frequent patterns.
Actually the Apriori algorithm consists of two parts, where the first part finds frequent patterns and the second part builds association rules from them.
For the BRL algorithm, we are only interested in the frequent patterns that are generated in the first part of Apriori.</p>
<p>In the first step, the Apriori algorithm starts with all feature values that have a support greater than the minimum support defined by the user.
If the user says that the minimum support should be 10% and only 5% of the houses have <span class="math inline">\(size=big\)</span>, we would remove that feature value and keep only <span class="math inline">\(size=medium\)</span> and <span class="math inline">\(size=small\)</span> as patterns.
This does not mean that the houses are removed from the data, it just means that <span class="math inline">\(\text{size=big}\)</span> is not returned as frequent pattern.
Based on frequent patterns with a single feature value, the Apriori algorithm iteratively tries to find combinations of feature values of increasingly higher order.
Patterns are constructed by combining <span class="math inline">\(feature=value\)</span> statements with a logical AND, e.g. <span class="math inline">\(\text{size=medium}\land\text{location=bad}\)</span>.
Generated patterns with a support below the minimum support are removed.
In the end we have all the frequent patterns.
Any subset of a frequent pattern is frequent again, which is called the apriori property.
It makes sense intuitively:
By removing a condition from a pattern, the reduced pattern can only cover more or the same number of data points (support), but not less.
For example, if 20% of the houses are <span class="math inline">\(\text{size=medium}\land\text{location=good}\)</span>, then the support of houses that are only <span class="math inline">\(\text{size=medium}\)</span> is 20% or greater.
The apriori property is used to reduce the number of patterns to be inspected.
Only in the case of frequent patterns we have to check patterns of higher order.</p>
<p>Now we are done with pre-mining conditions for the Bayesian Rule List algorithm.
But before we go into the details of BRL, I would like to hint at another way for rule-learning based on pre-mined patterns.
Other approaches suggest including the outcome of interest into the frequent pattern mining process and also executing the second part of the Apriori algorithm that builds IF-THEN rules.
Since the algorithm is unsupervised, the THEN-part also contains feature values we are not interested in.
But we can filter by rules that have only the outcome of interest in the THEN-part.
These rules already form a decision set, but it would also be possible to arrange, prune, delete or recombine the rules.</p>
<p>In the BRL approach however, we work with the frequent patterns and learn the THEN-part and how to arrange the patterns into a decision list using Bayesian statistics.</p>
<p><strong>Learning Bayesian Rule Lists</strong></p>
<p>The goal of the BRL algorithm is to learn an accurate decision list using a selection of the pre-mined conditions, while prioritizing lists with few rules and short conditions.
BRL addresses this goal by defining a distribution of decision lists with prior distributions for the length of conditions (preferably shorter rules) and the number of rules (preferably a shorter list).</p>
<p>The posteriori probability distribution of lists, makes it possible to say how likely a decision list is, given assumptions of shortness and how well the list fits the data.
Our goal is to find the list that maximizes this posterior probability.
Since it’s not possible to find the exact best list directly from the distributions of lists, BRL suggests the following recipe:
1) Generate an initial decision list, which is randomly drawn from the priori distribution.
2) Iteratively modify the list by adding, switching or removing rules, ensuring that the resulting lists follow the posterior distribution of lists.
3) Select the decision list from the sampled lists with the highest probability according to the posteriori distribution.</p>
<p>Let’s go over the algorithm more closely:
The algorithm starts with pre-mining feature value patterns with the FP-Growth algorithm.
BRL makes a number of assumptions about the distribution of the target and the distribution of the parameters that define the distribution of the target.
(Well, that’s Bayesian statistic.)
If you are unfamiliar with Bayesian statistics, don’t get too caught up in the following explanations.
It’s important to know that the Bayesian approach is a way to combine existing knowledge or requirements (so-called priori distributions) while also adapting to the data.
In the case of decision lists, the Bayesian approach makes sense, since the prior assumptions nudges the decision lists to be short with also short rules.</p>
<p>The goal is to sample decision lists <span class="math inline">\(d\)</span> from the posteriori distribution:</p>
<p><span class="math display">\[\underbrace{p(d|x,y,A,\alpha,\lambda,\eta)}_{posteriori}\propto\underbrace{p(y|x,d,\alpha)}_{likelihood}\cdot\underbrace{p(d|A,\lambda,\eta)}_{priori}\]</span></p>
<p>where <span class="math inline">\(d\)</span> is a decision list, <span class="math inline">\(x\)</span> are the features, <span class="math inline">\(y\)</span> is the target, <span class="math inline">\(A\)</span> the set of pre-mined conditions, <span class="math inline">\(\lambda\)</span> the prior expected length of the decision lists, <span class="math inline">\(\eta\)</span> the prior expected number of conditions in a rule, <span class="math inline">\(\alpha\)</span> the prior pseudo-count for the positive and negative classes (best fixed at <span class="math inline">\((1,1)\)</span>).</p>
<p><span class="math display">\[p(d|x,y,A,\alpha,\lambda,\eta)\]</span></p>
<p>quantifies how probable a decision list is, given the observed data and the priori assumptions.
This is proportional to the likelihood of the outcome <span class="math inline">\(y\)</span> given the decision list and the data times the probability of the list given prior assumptions and the pre-mined conditions.</p>
<p><span class="math display">\[p(y|x,d,\alpha)\]</span></p>
<p>is the likelihood of the observed <span class="math inline">\(y\)</span>, given the decision list and the data.
BRL assumes that <span class="math inline">\(y\)</span> is generated by a Dirichlet-Multinomial distribution.
The better the decision list <span class="math inline">\(d\)</span> explains the data, the higher the likelihood.</p>
<p><span class="math display">\[p(d|A,\lambda,\eta)\]</span></p>
<p>is the prior distribution of the decision lists.
It multiplicatively combines a truncated Poisson distribution (parameter <span class="math inline">\(\lambda\)</span>) for the number of rules in the list and a truncated Poisson distribution (parameter <span class="math inline">\(\eta\)</span>) for the number of feature values in the conditions of the rules.</p>
<p>A decision list has a high posterior probability if it explains the outcome <span class="math inline">\(y\)</span> well and is also likely according to the prior assumptions.</p>
<p>Estimations in Bayesian statistics are always a bit tricky, because we usually can’t directly calculate the correct answer, but we have to draw candidates, evaluate them and update our posteriori estimates (using the Markov chain Monte Carlo).
For decision lists this is even more tricky, because we have to draw from the distribution of decision lists.
The BRL authors propose to first draw an initial decision list and then iteratively modify it to generate samples of decision lists from the posterior distribution of the lists (a Markov chain of decision lists).
The results are potentially dependent on the initial decision list, so it is advisable to repeat this procedure to ensure a great variety of lists (default in the software implementation is 10 times).
The following recipe tells us how to draw an initial decision list:</p>
<ul>
<li>Pre-mine patterns with FP-Growth.</li>
<li>Sample the length <span class="math inline">\(m\)</span> for the list from a truncated Poisson distribution.</li>
<li>For the default rule: Sample the Dirichlet-Multinomial distribution parameter <span class="math inline">\(\theta_0\)</span> of the target value (i.e. the rule that applies when nothing else applies).</li>
<li>For decision list rule <span class="math inline">\(j=1,\ldots,m\)</span>, do:
<ul>
<li>Sample the length of the rule <span class="math inline">\(l_j\)</span> (number of conditions) for rule <span class="math inline">\(j\)</span></li>
<li>Sample a condition of length <span class="math inline">\(l_j\)</span> from the pre-mined conditions.</li>
<li>Sample the Dirichlet-Multinomial distribution parameter for the THEN-part (i.e. for the distribution of the target outcome given the rule)</li>
</ul></li>
<li>For each observation in the dataset:
<ul>
<li>Find the rule from the decision list that applies first (top to bottom).</li>
<li>Draw the predicted outcome from the probability distribution (Binomial) suggested by the rule that applies.</li>
</ul></li>
</ul>
<p>The next step is to generate many new lists starting from this initial sample to obtain many samples from the posterior distribution of decision lists.</p>
<p>The new decision lists are sampled by starting from the initial list and then randomly either moving a rule to a different position in the list or adding a rule to the current decision list from the pre-mined conditions or removing a rule from the decision list.
Which of the rules is switched, added or deleted is chosen at random.
At each step, the algorithm evaluates the posteriori probability of the decision list (mixture of accuracy and shortness).
The Metropolis Hastings algorithm ensures that we sample decision lists that have a high posterior probability.
This procedure provides us with many samples from the distribution of decision lists.
The BRL algorithm selects the decision list of the samples with the highest posterior probability.</p>
<p>That’s it with the theory, now let’s see the BRL method in action.
The examples use a faster variant of BRL called Scalable Bayesian Rule Lists (SBRL) by Yang et. al (2016) <a href="#fn18" class="footnote-ref" id="fnref18"><sup>18</sup></a>.
We use the SBRL algorithm to predict the <a href="cervical.html#cervical">risk for cervical cancer</a>.
I first had to discretize all input features for the SBRL algorithm to work.
For this purpose I binned the continuous features based on the frequency of the values (by quantiles).</p>
<p>We get the following rules:</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">rules</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">If {STDs=1} (rule[259]) then positive probability = 0.16049383</td>
</tr>
<tr class="even">
<td align="left">else if {Hormonal.Contraceptives..years.=[0,10)} (rule[82]) then positive probability = 0.04685408</td>
</tr>
<tr class="odd">
<td align="left">else (default rule) then positive probability = 0.27777778</td>
</tr>
</tbody>
</table>
<p>Note that we get sensible rules, since the prediction on the THEN-part is not the class outcome, but the predicted probability for cancer.</p>
<p>The conditions were selected from patterns that were pre-mined with the FP-Growth algorithm.
The following table displays the pool of conditions the SBRL algorithm could choose from for building a decision list.
The maximum number of feature values in a condition I allowed as a user was two.
Here is a sample of ten patterns:</p>
<table>
<thead>
<tr class="header">
<th align="left">pre-mined conditions</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">First.sexual.intercourse=[17.3,24.7),STDs=1</td>
</tr>
<tr class="even">
<td align="left">Hormonal.Contraceptives=0,STDs=0</td>
</tr>
<tr class="odd">
<td align="left">Num.of.pregnancies=[0,3.67),STDs..Number.of.diagnosis=[0,1)</td>
</tr>
<tr class="even">
<td align="left">Smokes=1</td>
</tr>
<tr class="odd">
<td align="left">First.sexual.intercourse=[10,17.3)</td>
</tr>
<tr class="even">
<td align="left">Smokes=1,STDs..Number.of.diagnosis=[0,1)</td>
</tr>
<tr class="odd">
<td align="left">STDs..number.=[1.33,2.67)</td>
</tr>
<tr class="even">
<td align="left">Num.of.pregnancies=[3.67,7.33)</td>
</tr>
<tr class="odd">
<td align="left">Num.of.pregnancies=[3.67,7.33),IUD..years.=[0,6.33)</td>
</tr>
<tr class="even">
<td align="left">Age=[13,36.7),STDs..Number.of.diagnosis=[1,2)</td>
</tr>
</tbody>
</table>
<p>Next, we apply the SBRL algorithm to the <a href="#bike">bike rental prediction task</a>.
This only works if the regression problem of predicting bike counts is converted into a binary classification task.
I have arbitrarily created a classification task by creating a label that is 1 if the number of biks exceeds 4000 bikes on a day, else 0.</p>
<p>The following list was learned by SBRL:</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">rules</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">If {yr=2011,temp=[-5.22,7.35)} (rule[718]) then positive probability = 0.01041667</td>
</tr>
<tr class="even">
<td align="left">else if {yr=2012,temp=[7.35,19.9)} (rule[823]) then positive probability = 0.88125000</td>
</tr>
<tr class="odd">
<td align="left">else if {yr=2012,temp=[19.9,32.5]} (rule[816]) then positive probability = 0.99253731</td>
</tr>
<tr class="even">
<td align="left">else if {season=SPRING} (rule[351]) then positive probability = 0.06410256</td>
</tr>
<tr class="odd">
<td align="left">else if {temp=[7.35,19.9)} (rule[489]) then positive probability = 0.44444444</td>
</tr>
<tr class="even">
<td align="left">else (default rule) then positive probability = 0.79746835</td>
</tr>
</tbody>
</table>
<p>Let’s predict the probability that the number of bikes will exceed 4000 for a day in 2012 with a temperature of 17 degrees Celsius.
The first rule doesn’t apply, since it only applies for days in 2011.
The second rule applies, because the day is in 2012 and 17 degrees lies in the interval <span class="math inline">\([7.35,19.9)\)</span>.
Our prediction for the probability is 88%.</p>
</div>
<div id="advantages-1" class="section level3">
<h3><span class="header-section-number">5.4.4</span> Advantages</h3>
<p>This section discusses the benefits of IF-THEN rules in general.</p>
<ul>
<li>IF-THEN rules are <strong>easy to interpret</strong>.
They are probably the most interpretable of the interpretable models.
This statement only applies if the number of rules is small, the conditions of the rules are short (maximum 3 I would say) and if the rules are organized in a decision list or a non-overlapping decision set.</li>
<li>Decision rules can be <strong>as expressive as decision trees, while being more compact</strong>.
Decision tree often also suffer from replicated sub-trees, that is, when the splits following a left and a right child node have the same structure.</li>
<li>The <strong>prediction with IF-THEN rules is fast</strong>, since only a few binary statements need to be checked to determine which rules apply.</li>
<li>Decision rules are <strong>robust</strong> against monotonous transformations of the input features, because only the threshold in the conditions changes.
They are also robust against outliers, since it only matters if a condition applies or not.</li>
<li>IF-THEN rules usually generate sparse models, which means that not many features are included.
They <strong>select only the relevant features</strong> for the model.
For example, a linear model assigns a weight to every input feature by default.
Features that are irrelevant can simply be ignored by IF-THEN rules.</li>
<li>Simple rules like from OneR <strong>can be used as baseline</strong> for more complex algorithms.</li>
</ul>
</div>
<div id="disadvantages-1" class="section level3">
<h3><span class="header-section-number">5.4.5</span> Disadvantages</h3>
<p>This section deals with the disadvantages of IF-THEN rules in general.</p>
<ul>
<li>The research and literature for IF-THEN rules focuses on classification and almost <strong>completely neglects regression</strong>.
While you can always divide a continuous target into intervals and turn it into a classification problem, you always lose information.
In general, approaches are more attractive if they can be used for both regression and classification.</li>
<li>Often the <strong>features also have to be categorical</strong>.
That means numeric features must be binned, if you want to use them.
There are many ways to cut a continuous feature into intervals, but this is not trivial and comes with many questions without clear answers.
How many intervals should the feature be divided into?
What’s the splitting criteria: Fixed interval lengths, quantiles or something else?
Dealing with binning continuous features is a non-trivial issue that is often neglected and people just use the next best method (like I did in the examples).</li>
<li>Many of the older rule-learning algorithms are prone to overfitting.
The algorithms presented here all have at least some safeguards to prevent overfitting:
OneR is limited because it can only use one feature (only problematic if the feature has too many levels or if there are many features, which equates to the multiple testing problem), RIPPER does pruning and Bayesian Rule Lists impose a prior distribution on the decision lists.</li>
<li>Decision rules are <strong>bad in describing linear relationships</strong> between features and output.
That’s a problem they share with the decision trees.
Decision trees and rules can only produce step-like prediction functions, where changes in the prediction are always jumps and never smooth curves.
This is related to the issue that the inputs have to be categorical (in decision trees, they are implicitly categorized by splitting them).</li>
</ul>
</div>
<div id="software-and-alternatives" class="section level3">
<h3><span class="header-section-number">5.4.6</span> Software and Alternatives</h3>
<ul>
<li>OneR is implemented in the <a href="https://cran.r-project.org/web/packages/OneR/">R package OneR</a>, which was used for the examples in this book.
OneR is also implemented in the <a href="(https://www.eecs.yorku.ca/tdb/_doc.php/userg/sw/weka/doc/weka/classifiers/rules/package-summary.html)">Weka machine learning library</a> and as such available in Java, R and Python.</li>
<li>RIPPER is also implemented in Weka. For the examples, I used the R implementation of JRIP in the <a href="https://cran.r-project.org/web/packages/RWeka/index.html">RWeka package</a>.</li>
<li>SBRL is available as <a href="https://cran.r-project.org/web/packages/sbrl/index.html">R package</a> (which I used for the examples), in <a href="https://github.com/datascienceinc/Skater">Python</a> or as <a href="https://github.com/Hongyuy/sbrlmod">C implementation</a>.</li>
</ul>
<p>I won’t even try to list all alternatives for learning decision rule sets and lists, but will point to some summarizing work.</p>
<ul>
<li>I recommend the book ‘Foundations of Rule Learning’ from Fuernkranz et. al (2012)<a href="#fn19" class="footnote-ref" id="fnref19"><sup>19</sup></a>.
It’s an extensive work on learning rules, for those who want to delve deeper into the topic.
It provides a holistic framework for thinking about learning rules and presents many rule learning algorithms.</li>
<li>I also recommend to checkout the <a href="https://www.eecs.yorku.ca/tdb/_doc.php/userg/sw/weka/doc/weka/classifiers/rules/package-summary.html">Weka rule learners</a>, which implement RIPPER, M5Rules, OneR, PART and many more.</li>
<li>IF-THEN rules can be used in linear models as described in this book in the chapter about the <a href="rulefit.html#rulefit">RuleFit algorithm</a>.</li>
</ul>

</div>
</div>
<div class="footnotes">
<hr />
<ol start="15">
<li id="fn15"><p>Cohen, W. (1995). Fast effective rule induction. Icml. Retrieved from <a href="http://www.inf.ufrgs.br/~alvares/CMP259DCBD/Ripper.pdf" class="uri">http://www.inf.ufrgs.br/~alvares/CMP259DCBD/Ripper.pdf</a><a href="rules.html#fnref15" class="footnote-back">↩</a></p></li>
<li id="fn16"><p>Letham, B., Rudin, C., McCormick, T. H., &amp; Madigan, D. (2015). Interpretable classifiers using rules and bayesian analysis: Building a better stroke prediction model. Annals of Applied Statistics, 9(3), 1350–1371. <a href="https://doi.org/10.1214/15-AOAS848" class="uri">https://doi.org/10.1214/15-AOAS848</a><a href="rules.html#fnref16" class="footnote-back">↩</a></p></li>
<li id="fn17"><p>Borgelt, C. (2005). An implementation of the FP-growth algorithm. Proceedings of the 1st International Workshop on Open Source Data Mining Frequent Pattern Mining Implementations - OSDM ’05, 1–5. <a href="http://doi.org/10.1145/1133905.1133907" class="uri">http://doi.org/10.1145/1133905.1133907</a><a href="rules.html#fnref17" class="footnote-back">↩</a></p></li>
<li id="fn18"><p>Yang, H., Rudin, C., &amp; Seltzer, M. (2016). Scalable Bayesian Rule Lists, 31. Retrieved from <a href="http://arxiv.org/abs/1602.08610" class="uri">http://arxiv.org/abs/1602.08610</a><a href="rules.html#fnref18" class="footnote-back">↩</a></p></li>
<li id="fn19"><p>Fuernkranz, J., Gamberger, D., &amp; Lavrač, N. (2012). Foundations of Rule Learning. Foundations of Rule Learning. <a href="https://doi.org/10.1007/978-3-540-75197-7_2" class="uri">https://doi.org/10.1007/978-3-540-75197-7_2</a><a href="rules.html#fnref19" class="footnote-back">↩</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="tree.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="rulefit.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/christophM/interpretable-ml-book/edit/master/04.5-interpretable-rules.Rmd",
"text": "Edit"
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
